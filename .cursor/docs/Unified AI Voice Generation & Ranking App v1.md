# Unified AI Voice Generation & Ranking App v1

## **0. Definitions**

| Term | Meaning |
| ----- | ----- |
| **ROOT** | Absolute path to the voice asset tree. Injected via env var `AUDIO_ROOT`. Defaults to `./output`. |
| **skin**, **voice**, **batch** | Directory names under `ROOT`. |
| **take-file** | An MP3 stored under `<batch>/takes/…`. E.g., `Intro_1_take_3.mp3`. |
| **rank** | Integer **1–5** or `null` (un-ranked). |
| **symlink** | A POSIX soft link pointing from `<batch>/ranked/<rank-folder>/…` to the original take file. |
| **LOCKED sentinel** | Empty file named `LOCKED` in the batch root that freezes further ranking edits. |
| **Generation Job** | An asynchronous task managed by Celery to generate a batch of takes. |
| **Task ID** | Unique identifier for a Celery generation job. |
| **Script** | Input CSV file defining lines (`Function`, `Line`) for generation. |
| **Metadata** | Data stored in `metadata.json` describing a batch and its takes. |

---

## **1. Overview**

This application provides a unified web interface for game designers to:
1. Configure and initiate the generation of AI voice lines (takes) using the ElevenLabs API based on an input script (CSV).
2. Monitor the progress of asynchronous generation jobs.
3. Browse completed batches of takes.
4. Listen to and rank the generated takes (1-5) within a batch.
5. Lock a batch once ranking is complete.

The system uses a Flask backend, a React frontend, Celery for background tasks, and Redis for task queueing and status tracking. Ranking state is primarily managed via filesystem operations (`metadata.json`, symlinks) within a defined directory structure.

---

## **2. Directory-tree Contract (Output)**

*Applies to the structure created by the Generation Job and used by the Ranking system.*

```
<ROOT>/<SkinName>/<VoiceName-VoiceID>/<BatchID>/
│
├── takes/                #   **ALWAYS real MP3s created by generator**
│   └── Intro_1_take_3.mp3
│
├── ranked/               #   **ONLY symlinks created by ranking actions**, one extra level per rank
│   ├── 01/
│   │   └── Intro_1_take_3.mp3 -> ../../takes/Intro_1_take_3.mp3
│   ├── 02/
│   ├── 03/
│   ├── 04/
│   └── 05/
│
├── metadata.json         #   Authoritative truth for ranking, see §3
└── (optional) LOCKED     #   Presence = batch read-only for ranking
```

**NEVER rename or move the source MP3s in `takes/`.** Ranking actions affect only `metadata.json` and the symlink tree. Locking affects only the `LOCKED` file and `metadata.json`.

---

## **3. `metadata.json` Schema (v1)**

*Generated by the Celery task upon successful batch completion. Updated by ranking API calls.*

```json
{
  "batch_id": "20250417-000837-voiceID", // Includes voice ID marker
  "skin_name": "SkinName",
  "voice_name": "VoiceName-VoiceID",
  "generated_at_utc": "ISO-8601", // Set when generation job finishes
  "generation_params": { ... }, // Copy of params used for generation (voices, settings, etc.)
  "ranked_at_utc": null, // Filled when batch locked via API
  "takes": [
    {
      "file": "Intro_1_take_3.mp3", // Basename only
      "line": "Intro_1",           // From input script 'Function' column
      "script_text": "The actual text.", // From input script 'Line' column
      "take_number": 3,            // 1-based index for this line
      "generation_settings": {     // Settings used for this specific take
          "stability": 0.5,
          "similarity_boost": 0.75,
          "style": 0.45,
          "use_speaker_boost": true,
          "speed": 1.0
      },
      "rank": null,                // 1-5 or null
      "ranked_at": null            // ISO-8601 UTC, set when rank != null
    },
    // ... more takes
  ]
}
```

---

## **4. Back-end (Flask + Celery + Redis)**

### **4.1 Folder Layout**

```
backend/
│   app.py             # Main Flask app, API endpoints
│   celery_app.py      # Celery application factory/instance
│   tasks.py           # Celery task definitions (e.g., run_generation)
│   utils_fs.py        # Filesystem helpers (load/save metadata, symlinks, lock)
│   utils_elevenlabs.py # Helper for ElevenLabs API interaction
│   config.py          # Flask/Celery configuration loading
│   requirements.txt   # Python dependencies
│   logging_config.yaml # Optional: configure logging
└── tests/             # Pytest tests
    └── test_utils_fs.py
    └── test_api_ranking.py
    └── test_api_generation.py
    └── test_tasks.py
```

### **4.2 Environment Variables Required**

```
# Flask specific
FLASK_ENV=development # or production
SECRET_KEY=a-very-strong-secret-key # For Flask sessions/signing
AUDIO_ROOT=./output # Path to voice asset tree root

# Celery / Redis
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/0

# ElevenLabs
ELEVENLABS_API_KEY=sk_...

# Optional
LOG_LEVEL=INFO
LOG_FILE=/path/to/app.log # If logging to file
```

### **4.3 Async Task Management (Celery + Redis)**

*   **Broker & Backend:** Redis is used for both message queueing and storing task results/status.
*   **Task Definition (`tasks.py`):**
    *   `run_generation(config_json: str)`: The primary Celery task.
        *   Accepts JSON string containing all generation parameters (target skin, voice IDs, script content/path, variant count, quality settings, ElevenLabs config).
        *   Orchestrates the generation process:
            *   Fetches voice details if needed.
            *   Iterates through lines in the script and variants.
            *   Calls ElevenLabs API via `utils_elevenlabs.py` (handles retries, errors).
            *   Saves MP3s to the correct `<batch>/takes/` directory.
            *   Tracks progress and updates task state via Celery's API (`self.update_state(...)`).
            *   On completion, generates the final `metadata.json` matching the schema in §3.
            *   Returns the `batch_id` on success.
        *   Logs detailed progress and errors.
*   **Status Tracking:** The Flask API provides an endpoint to query task status using the Task ID, retrieving the state from the Redis result backend.

### **4.4 HTTP API (Flask)**

*   All routes prefixed with `/api`.
*   Uses Flask-CORS for frontend interaction.
*   Input validation on all relevant endpoints.
*   Consistent JSON responses: `{"data": ...}` on success (2xx), `{"error": "message"}` on failure (4xx/5xx).

| Verb  | Path                          | Body / Query                     | Response                                   | Side-effects                                                                 |
| :---- | :---------------------------- | :------------------------------- | :----------------------------------------- | :--------------------------------------------------------------------------- |
| **Generation** |                       |                                  |                                            |                                                                              |
| POST  | `/api/generate`               | JSON body with generation config | `202 {"task_id": "..."}`                   | Enqueues `run_generation` Celery task.                                       |
| GET   | `/api/generate/{task_id}/status` | none                             | `200 {"status": "...", "progress": ...}` | Queries Celery result backend (Redis) for task status.                       |
| GET   | `/api/voices`                 | none                             | `200 {"data": [{"id": ..., "name": ...}]}` | Fetches available voices from ElevenLabs API (cached).                       |
| **Ranking** |                           |                                  |                                            |                                                                              |
| GET   | `/api/batches`                | none                             | JSON list `{skin, voice, batch_id}` found. | Scans `AUDIO_ROOT` filesystem.                                               |
| GET   | `/api/batch/{batch_id}`       | none                             | Entire `metadata.json` (200) or `404`.     | Reads `metadata.json` via `utils_fs.load_metadata`.                          |
| PATCH | `/api/batch/{batch_id}/take/{filename}` | `{"rank": 1-5 or null}`          | `200 {"data": {}}` on success; 400/404/423. | Updates `metadata.json`, rebuilds symlinks via `utils_fs`.                   |
| POST  | `/api/batch/{batch_id}/lock`  | none                             | `200 {"data": {locked:true}}`              | Writes `LOCKED`, updates `ranked_at_utc` in `metadata.json` via `utils_fs`. |
| **Audio Streaming** |                 |                                  |                                            |                                                                              |
| GET   | `/audio/<path:relpath>`       | none                             | Audio file stream (MP3)                    | `send_file` with `conditional=True` for Range requests. `relpath` from ROOT. |

### **4.5 Filesystem Helpers (`utils_fs.py`)**

*   `load_metadata(batch_dir) -> dict`: Loads and parses `metadata.json`. Raises error if not found/invalid.
*   `save_metadata(batch_dir, data) -> None`: Atomically saves updated metadata to `metadata.json`.
*   `rebuild_symlinks(batch_dir, metadata) -> None`: Clears `ranked/`, recreates tree based on ranks in `metadata`. Uses atomic rename.
*   `lock_batch(batch_dir) -> None`: Creates `LOCKED` sentinel. (Metadata update handled separately by API endpoint).
*   `is_locked(batch_dir) -> bool`: Checks for `LOCKED` file presence.
*   `find_batches(root_dir) -> list[dict]`: Scans filesystem for valid batch structures.

### **4.6 Logging**

*   Configurable via `LOG_LEVEL` env var (default INFO).
*   Outputs to console by default, optionally to `LOG_FILE`.
*   Standard format: `[Timestamp] [Level] [Module] Message`.
*   Celery task logs include task ID.
*   Flask logs include request context.

---

## **5. Front-end (React + TypeScript + Vite)**

### **5.1 Folder Layout**

```
frontend/
│   vite.config.ts
│   tsconfig.json
│   package.json
│   index.html
└── src/
    │   main.tsx           # App entry point
    │   App.tsx            # Main router/layout
    │   api.ts             # Fetch wrappers for backend API
    │   types.ts           # Shared TypeScript types
    │   hooks/             # Custom React hooks (e.g., usePolling)
    │   contexts/          # React context definitions (e.g., RankingContext)
    ├── pages/             # Top-level route components
    │    ├── GenerationPage.tsx
    │    ├── BatchListPage.tsx
    │    └── RankingPage.tsx # Container for ranking UI
    └── components/        # Reusable UI components
         ├── generation/     # Components specific to generation config/monitoring
         │   ├── GenerationForm.tsx
         │   ├── VoiceSelector.tsx
         │   └── TaskMonitor.tsx
         ├── ranking/        # Components specific to ranking (based on original spec)
         │   ├── LineList.tsx
         │   ├── TakeRow.tsx
         │   ├── RankSlots.tsx
         │   └── AudioPlayer.tsx
         ├── shared/         # Common components (Buttons, Modals, etc.)
         └── ...
    └── tests/             # Vitest / React Testing Library tests
```

### **5.2 State Management**

*   **Ranking:** React Context (`RankingContext`) similar to original spec §4.2 manages state for a single batch being ranked (`batchId`, `takesByLine`, `updateRank` function).
*   **Generation:** Component-level state or dedicated context for managing form inputs, task monitoring (list of active task IDs, statuses).
*   **Global State:** Potentially Zustand or Redux Toolkit if complexity grows significantly (unlikely needed initially).

### **5.3 Major Components & UX Behaviour**

#### **Generation (`GenerationPage.tsx`, `components/generation/`)**

*   **`GenerationForm`**:
    *   Fetches available voices via `GET /api/voices` and populates `VoiceSelector`.
    *   Allows selecting multiple voices.
    *   Inputs for Skin Name, Variants per line.
    *   Sliders/inputs for stability, similarity, style, speed ranges.
    *   Checkbox for speaker boost.
    *   File input for uploading the script CSV (validation on client/server).
    *   "Start Generation" button (disabled until form is valid).
*   **`TaskMonitor`**:
    *   Displays a list of active/recent generation tasks.
    *   Uses a custom hook (`usePolling`) to periodically call `GET /api/generate/{task_id}/status` for each active task.
    *   Shows Task ID, status (Pending, Started, Success, Failure), progress info.
    *   Provides link to the Ranking page for successfully completed batches.

#### **Ranking (`BatchListPage.tsx`, `RankingPage.tsx`, `components/ranking/`)**

*   **`BatchListPage`**: Fetches batches via `GET /api/batches` and displays a list linking to `RankingPage`.
*   **`RankingPage`**: Fetches batch metadata via `GET /api/batch/{batch_id}`. Sets up `RankingContext`. Renders ranking UI. Includes "Lock Batch" button.
*   **`LineList`**, **`TakeRow`**, **`RankSlots`**, **`AudioPlayer`**: Implement functionality as described in original spec §4.3, using data from `RankingContext`.
    *   `LineList`: Virtualized, keyboard navigable.
    *   `TakeRow`: Play/pause, waveform (wavesurfer.js).
    *   `RankSlots`: Drag-and-drop ranking (react-beautiful-dnd), hotkeys, rank update logic (client-side cascading + debounced PATCH call).
    *   `AudioPlayer`: Web Audio API for playback, pre-decoding/caching.
*   **Locking UX**: Confirmation modal before calling `POST /api/batch/{batch_id}/lock`. UI becomes read-only after successful lock.

### **5.4 API Interaction (`api.ts`)**

*   Provides typed functions wrapping `fetch` for all backend API endpoints.
*   Handles base URL, JSON parsing, basic error handling.

### **5.5 Service Worker (Optional - Vite PWA Plugin)**

*   If implemented: Cache strategy "stale-while-revalidate" for `/audio/` responses, configurable size/file limits (e.g., 50 files / 80 MB).

---

## **6. Testing Strategy**

*   **Backend (Pytest):**
    *   **Unit Tests:**
        *   `test_utils_fs.py`: Test metadata load/save, symlink logic, locking, batch finding. Mock `os` functions.
        *   `test_utils_elevenlabs.py`: Test API interaction logic (mock `requests`).
        *   Test individual Flask route handler logic (mocking helpers/Celery).
    *   **Integration Tests:**
        *   `test_api_ranking.py`: Test ranking API endpoints (`/api/batch/...`, `/api/batches`, `/api/lock`) using Flask test client. Set up mock filesystem using `pyfakefs` or temporary directories. Assert file changes and API responses.
        *   `test_api_generation.py`: Test generation API endpoints (`/api/generate`, `/api/generate/.../status`, `/api/voices`). Mock Celery `delay` and result backend. Mock ElevenLabs API calls.
    *   **Task Tests (`test_tasks.py`):**
        *   Test `run_generation` Celery task directly. Mock filesystem, ElevenLabs API, Celery `update_state`. Assert correct files/metadata are produced based on input config.
*   **Frontend (Vitest + React Testing Library):**
    *   **Unit Tests:** Test utility functions, custom hooks.
    *   **Component Tests:** Test rendering and interaction logic for individual components (e.g., `GenerationForm`, `TakeRow`, `RankSlots`). Mock API calls (`msw` - Mock Service Worker).
    *   **Integration Tests:** Test interactions between components within pages (e.g., form submission triggers API call, ranking updates context).
*   **End-to-End (Optional - Playwright/Cypress):**
    *   Simulate full user flows: configuring and starting generation, monitoring status, navigating to ranking page, ranking takes, locking batch. Requires running full stack (Flask, React, Celery, Redis).

---

## **7. Dockerization**

### **7.1 Backend Dockerfile (`backend/Dockerfile`)**

```dockerfile
# Use an official Python runtime as a parent image
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# Set work directory
WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# Copy project code
COPY . .

# Expose port (for Flask)
EXPOSE 5000

# Default command can be overridden by docker-compose
# CMD ["flask", "run", "--host=0.0.0.0"] # Example, actual command in docker-compose
```

### **7.2 Frontend Dockerfile (`frontend/Dockerfile`)**

```dockerfile
# Use an official Node runtime as a parent image
FROM node:20-alpine

# Set work directory
WORKDIR /app

# Copy package.json and package-lock.json (if available)
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy project code
# This allows us to use the node_modules cache from the previous layer
COPY . .

# Expose port (for Vite dev server)
EXPOSE 5173

# Command to run the Vite dev server
CMD ["npm", "run", "dev", "--", "--host"] # --host makes it accessible outside container
```

### **7.3 Docker Compose (`docker-compose.yml`)**

```yaml
version: '3.8'

services:
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "5000:5000"
    volumes:
      - ./backend:/app  # Mount local code for live reload
      - ./output:/app/output # Mount output directory into container
    env_file:
      - .env # Pass environment variables
    environment:
      - FLASK_ENV=development
      # AUDIO_ROOT is now relative to WORKDIR inside container
      - AUDIO_ROOT=/app/output
    command: flask --app app:app run --host=0.0.0.0 --port=5000
    depends_on:
      - redis

  worker:
    build:
      context: ./backend
      dockerfile: Dockerfile
    volumes:
      - ./backend:/app
      - ./output:/app/output
    env_file:
      - .env
    environment:
      - AUDIO_ROOT=/app/output
    # Command to run the Celery worker
    command: celery -A celery_app:celery_app worker --loglevel=INFO
    depends_on:
      - redis

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "5173:5173"
    volumes:
      - ./frontend:/app        # Mount local code
      - /app/node_modules    # Avoid overwriting node_modules from host
    depends_on:
      - backend # Optional, depends if frontend needs backend running at build time

volumes:
  redis_data:
```

---

## **8. Build & Run (Docker Compose)**

The primary way to run the application locally for development is using Docker Compose.

```bash
# Build images (if not already built) and start all services
docker-compose up --build

# Start services (using existing images if possible)
docker-compose up

# Stop services
docker-compose down

# Stop services and remove volumes (like Redis data)
docker-compose down -v

# Run commands inside a running service container
docker-compose exec backend pytest # Example: Run backend tests
docker-compose exec frontend npm run test # Example: Run frontend tests
docker-compose exec backend flask --help # Example: Run flask commands
```

The `Makefile` can still be used for convenience targets like `test` or `clean`, but should ideally execute commands via `docker-compose exec` for consistency.

---

## **9. Exact Dependency Versions (Target)**

*   (No change from previous spec version, specified in `requirements.txt` and `package.json`)

---

## **10. Minimal Getting Started (Docker)**

```bash
# 1. Ensure Docker Desktop is installed and running.
# 2. Clone the repository
git clone <repo>
cd <repo>

# 3. Create .env file from .env.example (or manually)
#    Fill in ELEVENLABS_API_KEY, SECRET_KEY
#    Note: CELERY_BROKER_URL/CELERY_RESULT_BACKEND should use 'redis' hostname
#          e.g., redis://redis:6379/0
#    Note: AUDIO_ROOT is set via docker-compose environment, not needed in .env
cp .env.example .env
# --> Edit .env <--

# 4. Build and start the application
docker-compose up --build

# 5. Open frontend in browser (http://localhost:5173)
#    Flask API is accessible via frontend proxy or directly at http://localhost:5000

# 6. Stop the application
#    Press Ctrl+C in the terminal where docker-compose is running, or run:
#    docker-compose down
```

---

**This is the entire, self-contained tech spec for v1 (Dockerized).** 